# Java多线程面试题及答案

## 基础概念篇

### 1. 进程和线程有什么区别？
答：进程和线程的主要区别如下：
- **资源分配**：进程是资源分配的基本单位，每个进程都有独立的内存空间；线程是CPU调度的基本单位，同一进程内的线程共享进程的内存空间
- **系统开销**：创建和销毁进程的开销较大，而线程的开销相对较小
- **通信方式**：进程间通信需要通过IPC机制（如管道、消息队列等），而线程间可以直接访问共享内存
- **独立性**：进程之间相互独立，一个进程崩溃不会影响其他进程；同一进程内的线程共享数据，一个线程崩溃可能会影响整个进程

### 2. 什么是线程安全？如何保证线程安全？
答：线程安全是指多个线程访问同一个对象时，无论操作系统如何调度这些线程，都不会出现错误的结果或不确定的行为。

保证线程安全的方法有：
1. **使用同步机制**：如synchronized关键字、Lock接口等
2. **使用原子类**：如AtomicInteger、AtomicReference等
3. **使用线程安全的集合**：如ConcurrentHashMap、CopyOnWriteArrayList等
4. **使用ThreadLocal**：为每个线程提供独立的变量副本
5. **使用不可变对象**：创建后状态不能被修改的对象天然线程安全

### 3. Java中实现多线程有几种方式？
答：Java中实现多线程主要有以下几种方式：
1. **继承Thread类**：重写run()方法
2. **实现Runnable接口**：实现run()方法，通过Thread构造函数传入
3. **实现Callable接口**：实现call()方法，可通过FutureTask包装后传给Thread
4. **使用线程池**：通过ExecutorService执行任务

推荐使用实现Runnable接口或Callable接口的方式，因为Java不支持多重继承，实现接口更加灵活。

### 4. 线程有哪些状态？请详细说明。
答：Java线程在其生命周期中有6种状态，定义在Thread.State枚举中：
1. **NEW(新建)**：线程被创建但尚未调用start()方法
2. **RUNNABLE(可运行)**：线程正在JVM中执行，可能正在运行也可能正在等待CPU时间片
3. **BLOCKED(阻塞)**：线程被阻塞等待监视器锁进入同步块/方法或重入同步块/方法
4. **WAITING(无限期等待)**：线程等待其他线程执行特定操作，如调用Object.wait()、Thread.join()等
5. **TIMED_WAITING(限期等待)**：线程等待其他线程执行特定操作，但设置了等待时间，如Thread.sleep()、Object.wait(timeout)等
6. **TERMINATED(终止)**：线程执行完毕或因异常退出

### 5. sleep()、wait()、yield()有什么区别？
答：
| 方法 | 归属 | 锁释放 | 作用对象 | 可否唤醒 | 异常声明 |
|------|------|--------|----------|----------|----------|
| sleep() | Thread类 | 否 | 当前线程 | 否 | InterruptedException |
| wait() | Object类 | 是 | 当前对象 | 是 | InterruptedException |
| yield() | Thread类 | 否 | 当前线程 | 否 | 无 |

## synchronized篇

### 6. synchronized的实现原理是什么？
答：synchronized通过对象监视器(Monitor)实现同步机制：
1. **对象头**：每个Java对象在内存中都有对象头，其中包含Mark Word，用于存储对象的hashCode、分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等信息
2. **Monitor对象**：每个对象都关联一个Monitor对象，Monitor内部有两个队列：_WaitSet和_EntryList，用来保存处于等待状态和阻塞状态的线程
3. **加锁过程**：当线程进入synchronized代码块时，会尝试获取对象的monitor，如果获取失败则进入阻塞状态
4. **释放锁**：执行完synchronized代码块后，线程会释放monitor

### 7. synchronized和ReentrantLock有什么区别？
答：
1. **实现机制**：synchronized是JVM层面的关键字，ReentrantLock是API层面的锁
2. **灵活性**：ReentrantLock提供更多功能，如公平锁、可中断锁、超时锁、多个条件变量等
3. **性能**：在JDK1.6之前，ReentrantLock性能优于synchronized；JDK1.6及以后两者性能相差不大
4. **锁释放**：synchronized自动释放锁，ReentrantLock需要手动释放(unlock)
5. **可重入性**：两者都支持可重入，但ReentrantLock还提供getHoldCount()等方法查询重入次数

### 8. 什么是可重入锁？为什么需要可重入锁？
答：可重入锁是指同一个线程可以多次获取同一把锁，而不会出现死锁。

需要可重入锁的原因：
1. **避免死锁**：在递归调用或嵌套调用同步方法时，避免线程自己跟自己产生死锁
2. **简化编程模型**：开发者不需要关注锁的获取和释放细节，可以专注于业务逻辑

Java中的synchronized和ReentrantLock都是可重入锁。

### 9. synchronized锁升级的过程是怎样的？
答：synchronized在JDK1.6之后引入了锁升级机制，主要包括以下几种状态：
1. **无锁状态**：对象刚创建时的状态
2. **偏向锁**：当只有一个线程访问同步块时，JVM会将对象头中的线程ID设为当前线程ID，下次该线程再次访问时无需CAS操作
3. **轻量级锁**：当有第二个线程尝试获取锁时，偏向锁会升级为轻量级锁，通过CAS操作将对象头中的Mark Word替换为指向线程栈中锁记录的指针
4. **重量级锁**：当轻量级锁竞争激烈时，会膨胀为重量级锁，此时线程会进入阻塞状态

锁升级的方向是单向的：无锁→偏向锁→轻量级锁→重量级锁，但不会降级。

### 10. synchronized可以作用在哪些地方？有什么区别？
答：synchronized可以作用在以下三个地方：
1. **实例方法**：锁住的是当前实例对象(this)
2. **静态方法**：锁住的是当前类的Class对象
3. **代码块**：锁住的是synchronized括号中的对象

区别在于锁的作用范围不同，实例方法锁的是对象实例，静态方法锁的是类对象，代码块可以灵活指定锁对象。

## volatile篇

### 11. volatile关键字的作用是什么？
答：volatile关键字有两个主要作用：
1. **保证可见性**：当一个线程修改了volatile变量的值，新值对其他线程来说是立即可见的
2. **禁止指令重排序**：volatile变量的读写操作不会与其他代码重排序，保证了一定的有序性

但volatile不能保证原子性，只能保证单次读/写的原子性，不能保证复合操作的原子性。

### 12. volatile变量和普通变量在内存访问上有何不同？
答：
1. **可见性保障**：对普通变量的修改可能只存在于工作内存中，而volatile变量的修改会立即刷新到主内存
2. **内存屏障**：对volatile变量的读写会在其前后插入内存屏障，防止指令重排序
3. **原子性**：volatile只能保证单次读/写的原子性，对于long和double这样的64位数据类型，在32位JVM上普通变量的读写可能不是原子的，而volatile变量可以保证原子性

### 13. volatile能保证原子性吗？请举例说明。
答：volatile不能保证复合操作的原子性。

例如：
```java
public class VolatileAtomicityDemo {
    private volatile int count = 0;
    
    public void increment() {
        count++; // 这不是一个原子操作
    }
}
```

count++操作实际上包含三个步骤：
1. 从主内存读取count的值到工作内存
2. 在工作内存中执行+1操作
3. 将新值写回主内存

这三个步骤不是原子性的，多线程环境下可能出现竞态条件。

## 线程池篇

### 14. 为什么要使用线程池？有什么优势？
答：使用线程池的优势有：
1. **降低资源消耗**：通过重复利用已创建的线程降低线程创建和销毁造成的消耗
2. **提高响应速度**：任务到达时，无需等待线程创建就能立即执行
3. **提高线程的可管理性**：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控

### 15. 线程池的参数有哪些？各自的作用是什么？
答：ThreadPoolExecutor的构造函数有7个参数：
1. **corePoolSize**：核心线程数，即使线程空闲也不会被回收（除非allowCoreThreadTimeOut为true）
2. **maximumPoolSize**：最大线程数，线程池中允许的最大线程数
3. **keepAliveTime**：空闲线程存活时间，当线程数大于核心线程数时，多余的空闲线程在等待新任务时的最长等待时间
4. **unit**：keepAliveTime的时间单位
5. **workQueue**：工作队列，用于保存等待执行的任务
6. **threadFactory**：线程工厂，用于创建新线程
7. **handler**：拒绝策略，当线程池和队列都满了时，对新任务的处理策略

### 16. 线程池的工作流程是怎样的？
答：线程池的工作流程如下：
1. 如果正在运行的线程数小于corePoolSize，直接创建新线程执行任务
2. 如果正在运行的线程数大于等于corePoolSize，将任务加入workQueue
3. 如果workQueue已满，且正在运行的线程数小于maximumPoolSize，创建新线程执行任务
4. 如果workQueue已满，且正在运行的线程数大于等于maximumPoolSize，执行拒绝策略

### 17. 常见的拒绝策略有哪些？
答：ThreadPoolExecutor提供了四种内置的拒绝策略：
1. **AbortPolicy**：直接抛出RejectedExecutionException异常，默认策略
2. **CallerRunsPolicy**：由调用线程（提交任务的线程）处理该任务
3. **DiscardPolicy**：直接丢弃任务，不抛出异常
4. **DiscardOldestPolicy**：丢弃队列最前面的任务，然后重新尝试执行任务

### 18. 各种拒绝策略的应用场景是什么？
答：不同拒绝策略适用于不同的业务场景：

**AbortPolicy**：
- 适用于对数据完整性要求很高的系统，如金融交易系统
- 当系统过载时，宁愿抛出异常也不愿丢失任务
- 适用于有完善异常处理机制的系统，可以对拒绝的任务进行特殊处理

**CallerRunsPolicy**：
- 适用于允许延迟执行但不能丢失任务的场景
- 当线程池和队列都满时，由提交任务的线程直接执行任务，起到一种"减压"作用
- 适用于提交任务的线程可以承受一定执行时间的场景，如一些后台处理任务

**DiscardPolicy**：
- 适用于允许偶尔丢失任务的场景，如日志收集系统
- 对于非核心业务，可以接受任务被丢弃
- 实时性要求高的系统，当来不及处理时宁可丢弃也不愿阻塞

**DiscardOldestPolicy**：
- 适用于任务之间有优先级关系，新任务比旧任务更重要的场景
- 适用于任务执行结果时效性强的系统，旧任务已失去价值
- 适用于任务执行时间相对较长，队列中积压的任务较多的场景

### 19. 如何合理配置线程池参数？
答：线程池参数的配置需要根据业务场景来决定：
1. **CPU密集型任务**：线程数设置为CPU核心数+1，减少线程上下文切换的开销
2. **IO密集型任务**：线程数可以设置为CPU核心数*2或更高，因为IO操作期间CPU是空闲的
3. **混合型任务**：可以根据任务的CPU时间和IO时间比例来计算最优线程数

公式：最佳线程数 = CPU核心数 * (1 + IO耗时/CPU耗时)

## 并发工具类篇

### 20. CountDownLatch和CyclicBarrier有什么区别？
答：
1. **作用**：CountDownLatch用于一个或多个线程等待其他线程完成操作；CyclicBarrier用于一组线程相互等待到达某个屏障点
2. **计数方式**：CountDownLatch的计数器只能使用一次；CyclicBarrier的计数器可以重用
3. **调用方式**：CountDownLatch调用countDown()方法计数器递减；CyclicBarrier调用await()方法使线程阻塞
4. **应用场景**：CountDownLatch常用于主线程等待子线程完成；CyclicBarrier常用于多线程计算数据，最后合并计算结果

### 21. Semaphore有什么作用？适用于什么场景？
答：Semaphore（信号量）用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。

适用于以下场景：
1. **流量控制**：限制数据库连接数、线程池大小等
2. **资源池**：如数据库连接池、线程池等
3. **限流**：控制访问特定服务的并发数

### 22. 什么是CAS？有什么优缺点？
答：CAS(Compare And Swap)是比较并交换，是一种无锁的原子操作。它包含三个操作数：内存值V、旧的预期值A和要修改的新值B。当且仅当预期值A和内存值V相同时，才会将内存值V修改为B，否则什么都不做。

优点：
1. **非阻塞**：不会阻塞线程，提高并发性能
2. **避免死锁**：不需要锁机制，自然不会有死锁问题

缺点：
1. **ABA问题**：如果一个值原来是A，变成了B，又变回A，CAS操作会误认为它从未被改变过
2. **循环时间长开销大**：如果CAS一直不成功，会导致自旋消耗CPU资源
3. **只能保证一个共享变量的原子操作**：对多个共享变量操作时，无法保证原子性

### 23. 什么是乐观锁和悲观锁？
答：
- **悲观锁**：总是假设最坏的情况，每次拿数据时都认为别人会修改，所以每次拿数据时都会上锁。Java中的synchronized和ReentrantLock都是悲观锁的实现
- **乐观锁**：总是假设最好的情况，每次拿数据时都认为别人不会修改，所以不会上锁，但是在更新时会判断在此期间有没有人修改过数据。CAS就是乐观锁的实现

## 死锁篇

### 24. 什么是死锁？产生的条件是什么？
答：死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

死锁产生的四个必要条件（Coffman条件）：
1. **互斥条件**：一个资源每次只能被一个线程使用
2. **请求和保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放
3. **不剥夺条件**：线程已获得的资源在未使用完之前不能强行剥夺
4. **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系

### 25. 如何预防死锁？
答：破坏死锁产生的四个必要条件中的任何一个都可以预防死锁：
1. **破坏互斥条件**：允许某些资源同时被多个线程访问，但这并不适用于所有资源
2. **破坏请求和保持条件**：一次性申请所有需要的资源
3. **破坏不剥夺条件**：当线程申请不到资源时，主动释放已获得的资源
4. **破坏循环等待条件**：按序申请资源，给所有资源统一编号，按需申请

### 26. 如何排查死锁？
答：
1. **jstack命令**：使用jstack工具查看线程堆栈信息，可以直观看到死锁信息
2. **JConsole**：JDK自带的图形化监控工具，可以检测死锁
3. **VisualVM**：可视化的性能分析工具，也能检测死锁
4. **代码审查**：仔细检查代码中的加锁顺序和锁的使用方式

## Java内存模型篇

### 27. 什么是Java内存模型(JMM)？
答：Java内存模型(Java Memory Model)是Java虚拟机规范中定义的一种抽象规范，用于屏蔽各种硬件和操作系统的内存访问差异，实现Java程序在各个平台下都能达到一致的内存访问效果。

JMM定义了线程和主内存之间的抽象关系：
- 共享变量存储在主内存中，每个线程都有自己的工作内存
- 线程不能直接读写主内存中的变量，只能操作工作内存中的变量副本
- 不同线程之间无法直接访问对方工作内存中的变量

### 28. happens-before原则是什么？
答：happens-before是Java内存模型中最重要的规则之一，它是判断数据是否存在竞争、线程是否安全的主要依据。

happens-before的八大规则：
1. **程序次序规则**：一个线程内按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
2. **管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作
3. **volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作
4. **线程启动规则**：Thread对象的start()方法先行发生于此线程的每一个动作
5. **线程终止规则**：线程中所有的操作都先行发生于对此线程的终止检测
6. **线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. **对象终结规则**：一个对象的初始化完成先行发生于它的finalize()方法的开始
8. **传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论

### 29. 什么是内存屏障？
答：内存屏障(Memory Barrier)是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。

Java编译器也会根据内存屏障的规则禁止重排序，常见的内存屏障类型：
1. **LoadLoad屏障**：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕
2. **StoreStore屏障**：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见
3. **LoadStore屏障**：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕
4. **StoreLoad屏障**：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见

## 原子类篇

### 30. AtomicInteger的实现原理是什么？
答：AtomicInteger基于CAS(compare-and-swap)操作实现原子性。其核心字段value是一个volatile变量，保证了可见性。

主要方法的实现原理：
1. **getAndIncrement()**：通过Unsafe类的getAndAddInt方法实现，这是一个native方法，使用CAS操作
2. **compareAndSet()**：直接调用Unsafe类的compareAndSwapInt方法

当CAS操作失败时，会不断重试直到成功，这就是所谓的自旋操作。

### 31. AtomicStampedReference是什么？解决了什么问题？
答：AtomicStampedReference是带版本戳的原子引用类型，它维护了一个对象引用和一个int类型的版本戳。

它主要解决了CAS操作的ABA问题：
- **ABA问题**：一个值原来是A，变成了B，又变回A，CAS操作会误认为它从未被改变过
- **解决方式**：使用版本戳，每次修改时版本戳加1，这样即使值从A变为B再变为A，版本戳也会发生变化，CAS操作就会失败

## 总结

以上是Java多线程相关的常见面试题及参考答案。掌握这些知识点对于深入理解Java并发编程、通过技术面试以及在实际项目中编写高质量的并发代码都非常有帮助。在实际应用中，还需要结合具体业务场景选择合适的并发工具和同步机制。