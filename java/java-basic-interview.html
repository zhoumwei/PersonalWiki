<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Java基础面试题及答案 | PersonalWiki</title><meta name="description" content="My PersonalWiki Site">
    <link rel="preload" href="/assets/style-QXEKf4Y2.css" as="style"><link rel="stylesheet" href="/assets/style-QXEKf4Y2.css">
    <link rel="modulepreload" href="/assets/app-BvwJZ6kh.js"><link rel="modulepreload" href="/assets/java-basic-interview.html-DjUXvpr3.js">
    <link rel="prefetch" href="/assets/index.html-CbTDEAts.js" as="script"><link rel="prefetch" href="/assets/get-started.html-CjD3fAAo.js" as="script"><link rel="prefetch" href="/assets/index.html-DSrufwo5.js" as="script"><link rel="prefetch" href="/assets/flink-notes.html-BpXJ8u78.js" as="script"><link rel="prefetch" href="/assets/hadoop-notes.html-C4UlBBUF.js" as="script"><link rel="prefetch" href="/assets/hbase-notes.html-CTid9EA9.js" as="script"><link rel="prefetch" href="/assets/hive-notes.html-BCTrtLqN.js" as="script"><link rel="prefetch" href="/assets/spark-notes.html-DjBDa7xt.js" as="script"><link rel="prefetch" href="/assets/time-series-data.html-Cpf5Qxjz.js" as="script"><link rel="prefetch" href="/assets/index.html-BWfX9Mq_.js" as="script"><link rel="prefetch" href="/assets/anomaly-detection.html-Bg2YjLXz.js" as="script"><link rel="prefetch" href="/assets/solution-overview.html-CetPEQ_x.js" as="script"><link rel="prefetch" href="/assets/index.html-D_AXRVv7.js" as="script"><link rel="prefetch" href="/assets/redis-notes.html-BjkbebZR.js" as="script"><link rel="prefetch" href="/assets/index.html-Df8gWSBm.js" as="script"><link rel="prefetch" href="/assets/mysql-notes.html-s5dCwXKf.js" as="script"><link rel="prefetch" href="/assets/index.html-eSWmtd0l.js" as="script"><link rel="prefetch" href="/assets/css-interview.html-DluBQhYO.js" as="script"><link rel="prefetch" href="/assets/html-interview.html-Cyy3AGVn.js" as="script"><link rel="prefetch" href="/assets/javascript-interview.html-CG7UI4-t.js" as="script"><link rel="prefetch" href="/assets/layout-methods.html-pL0_j4Ng.js" as="script"><link rel="prefetch" href="/assets/react-interview.html-CIa2Sn63.js" as="script"><link rel="prefetch" href="/assets/vue-interview.html-K5pEBcjG.js" as="script"><link rel="prefetch" href="/assets/index.html-TRTe0zxa.js" as="script"><link rel="prefetch" href="/assets/android-interview.html-ada45Htj.js" as="script"><link rel="prefetch" href="/assets/jmm-notes.html-MDd7Ko4J.js" as="script"><link rel="prefetch" href="/assets/jvm-notes.html-DLuG0MRh.js" as="script"><link rel="prefetch" href="/assets/multithreading-interview.html-D5DrrSe3.js" as="script"><link rel="prefetch" href="/assets/multithreading-notes.html-DfVio_Fi.js" as="script"><link rel="prefetch" href="/assets/index.html-BnS01Ekr.js" as="script"><link rel="prefetch" href="/assets/fine-tuning.html-CjBB1ax_.js" as="script"><link rel="prefetch" href="/assets/llm-notes.html-QVyBkdng.js" as="script"><link rel="prefetch" href="/assets/prompt-engineering.html-DNhy9bB9.js" as="script"><link rel="prefetch" href="/assets/training-optimization.html-xAtwji5x.js" as="script"><link rel="prefetch" href="/assets/transformer-notes.html-CipMRP38.js" as="script"><link rel="prefetch" href="/assets/index.html-Cw2F1Agy.js" as="script"><link rel="prefetch" href="/assets/machine-learning.html-B-iGr0DC.js" as="script"><link rel="prefetch" href="/assets/index.html-Dg7P-8V_.js" as="script"><link rel="prefetch" href="/assets/kafka-notes.html-BetCbVDF.js" as="script"><link rel="prefetch" href="/assets/index.html-BKcXiGDb.js" as="script"><link rel="prefetch" href="/assets/nodejs-interview.html-B9dtC6T3.js" as="script"><link rel="prefetch" href="/assets/archive1.html-CU_-lS65.js" as="script"><link rel="prefetch" href="/assets/archive2.html-Dnyy_0hM.js" as="script"><link rel="prefetch" href="/assets/article1.html-An39HM8J.js" as="script"><link rel="prefetch" href="/assets/article10.html-B4wvKqrh.js" as="script"><link rel="prefetch" href="/assets/article11.html-BwLv2ZIG.js" as="script"><link rel="prefetch" href="/assets/article12.html-ey-3Numx.js" as="script"><link rel="prefetch" href="/assets/article2.html-B6IJZCZx.js" as="script"><link rel="prefetch" href="/assets/article3.html-WQYkFWda.js" as="script"><link rel="prefetch" href="/assets/article4.html-3reFRa1Y.js" as="script"><link rel="prefetch" href="/assets/article5.html-BAgHH7zk.js" as="script"><link rel="prefetch" href="/assets/article6.html-Ci6HTPLI.js" as="script"><link rel="prefetch" href="/assets/article7.html-CGCzq-HI.js" as="script"><link rel="prefetch" href="/assets/article8.html-DAf_qtAn.js" as="script"><link rel="prefetch" href="/assets/article9.html-BJ_PclXO.js" as="script"><link rel="prefetch" href="/assets/sticky.html-DzYDdEpa.js" as="script"><link rel="prefetch" href="/assets/sticky2.html-DxwKeFc6.js" as="script"><link rel="prefetch" href="/assets/index.html-SKjZhXJG.js" as="script"><link rel="prefetch" href="/assets/brew-tutorial.html-HINWWcf0.js" as="script"><link rel="prefetch" href="/assets/linux-notes.html-Bs6UdVSt.js" as="script"><link rel="prefetch" href="/assets/nvm-tutorial.html-CQ4cnbiJ.js" as="script"><link rel="prefetch" href="/assets/tencent-cloud-config.html-BAq6h3ta.js" as="script"><link rel="prefetch" href="/assets/404.html-Bocm2NQp.js" as="script"><link rel="prefetch" href="/assets/index.html-D7ucGqBj.js" as="script"><link rel="prefetch" href="/assets/index.html-Kt4soQse.js" as="script"><link rel="prefetch" href="/assets/index.html-DP6wngEx.js" as="script"><link rel="prefetch" href="/assets/index.html-CyRJUuAN.js" as="script"><link rel="prefetch" href="/assets/index.html-CSYpLAM6.js" as="script"><link rel="prefetch" href="/assets/index.html-DkIn-eRi.js" as="script"><link rel="prefetch" href="/assets/index.html-CFDck-Pn.js" as="script"><link rel="prefetch" href="/assets/index.html-BCj8RVxP.js" as="script"><link rel="prefetch" href="/assets/index.html-C6DXimEX.js" as="script"><link rel="prefetch" href="/assets/index.html-TPQAqjy9.js" as="script"><link rel="prefetch" href="/assets/index.html-Bdmct_gh.js" as="script"><link rel="prefetch" href="/assets/index.html-fHklgrv9.js" as="script"><link rel="prefetch" href="/assets/index.html-BKdawjmQ.js" as="script"><link rel="prefetch" href="/assets/index.html-Dam71-Kz.js" as="script"><link rel="prefetch" href="/assets/index.html-C4b-Z5oU.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><img class="vp-site-logo" src="/logo.svg" alt="PersonalWiki"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">PersonalWiki</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/article/" aria-label="Article"><!--[--><!--[--><!--]--><!--]-->Article<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/aiops/" aria-label="AIOps"><!--[--><!--[--><!--]--><!--]-->AIOps<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/bigdata/" aria-label="BigData"><!--[--><!--[--><!--]--><!--]-->BigData<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/cache/" aria-label="Cache"><!--[--><!--[--><!--]--><!--]-->Cache<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/database/" aria-label="Database"><!--[--><!--[--><!--]--><!--]-->Database<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/java/" aria-label="Java"><!--[--><!--[--><!--]--><!--]-->Java<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/llm/" aria-label="LLM"><!--[--><!--[--><!--]--><!--]-->LLM<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/ml/" aria-label="ML"><!--[--><!--[--><!--]--><!--]-->ML<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/mq/" aria-label="MQ"><!--[--><!--[--><!--]--><!--]-->MQ<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/nodejs/" aria-label="Node.js"><!--[--><!--[--><!--]--><!--]-->Node.js<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/system/" aria-label="System"><!--[--><!--[--><!--]--><!--]-->System<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/category/" aria-label="Category"><!--[--><!--[--><!--]--><!--]-->Category<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tag/" aria-label="Tag"><!--[--><!--[--><!--]--><!--]-->Tag<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/timeline/" aria-label="Timeline"><!--[--><!--[--><!--]--><!--]-->Timeline<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/article/" aria-label="Article"><!--[--><!--[--><!--]--><!--]-->Article<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/aiops/" aria-label="AIOps"><!--[--><!--[--><!--]--><!--]-->AIOps<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/bigdata/" aria-label="BigData"><!--[--><!--[--><!--]--><!--]-->BigData<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/cache/" aria-label="Cache"><!--[--><!--[--><!--]--><!--]-->Cache<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/database/" aria-label="Database"><!--[--><!--[--><!--]--><!--]-->Database<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/java/" aria-label="Java"><!--[--><!--[--><!--]--><!--]-->Java<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/llm/" aria-label="LLM"><!--[--><!--[--><!--]--><!--]-->LLM<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/ml/" aria-label="ML"><!--[--><!--[--><!--]--><!--]-->ML<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/mq/" aria-label="MQ"><!--[--><!--[--><!--]--><!--]-->MQ<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/nodejs/" aria-label="Node.js"><!--[--><!--[--><!--]--><!--]-->Node.js<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/system/" aria-label="System"><!--[--><!--[--><!--]--><!--]-->System<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/category/" aria-label="Category"><!--[--><!--[--><!--]--><!--]-->Category<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tag/" aria-label="Tag"><!--[--><!--[--><!--]--><!--]-->Tag<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/timeline/" aria-label="Timeline"><!--[--><!--[--><!--]--><!--]-->Timeline<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active">Java 基础 <!----></p><ul class="vp-sidebar-children" style=""><!--[--><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/java/java-basic-interview.html" aria-label="Java基础面试题及答案"><!--[--><!--[--><!--]--><!--]-->Java基础面试题及答案<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/java/jmm-notes.html" aria-label="Java内存模型(JMM)学习笔记"><!--[--><!--[--><!--]--><!--]-->Java内存模型(JMM)学习笔记<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/java/jvm-notes.html" aria-label="Java虚拟机(JVM)学习笔记"><!--[--><!--[--><!--]--><!--]-->Java虚拟机(JVM)学习笔记<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/java/multithreading-interview.html" aria-label="Java多线程面试题及答案"><!--[--><!--[--><!--]--><!--]-->Java多线程面试题及答案<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/java/multithreading-notes.html" aria-label="Java多线程编程学习笔记"><!--[--><!--[--><!--]--><!--]-->Java多线程编程学习笔记<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="java基础面试题及答案" tabindex="-1"><a class="header-anchor" href="#java基础面试题及答案"><span>Java基础面试题及答案</span></a></h1><h2 id="java语言基础" tabindex="-1"><a class="header-anchor" href="#java语言基础"><span>Java语言基础</span></a></h2><h3 id="_1-java语言有哪些特点" tabindex="-1"><a class="header-anchor" href="#_1-java语言有哪些特点"><span>1. Java语言有哪些特点？</span></a></h3><p>答：Java语言具有以下主要特点：</p><ol><li><strong>简单性</strong>：语法类似C++但去除了容易混淆的特性，如指针操作、多继承等</li><li><strong>面向对象</strong>：支持封装、继承、多态等面向对象特性</li><li><strong>分布式</strong>：支持网络编程，提供了丰富的网络应用编程接口</li><li><strong>健壮性</strong>：强制类型检查，提供异常处理机制，具有垃圾回收机制</li><li><strong>安全性</strong>：提供安全管理器和字节码验证器，防止恶意代码攻击</li><li><strong>平台无关性</strong>：通过JVM实现&quot;一次编写，到处运行&quot;</li><li><strong>可移植性</strong>：Java的数据类型大小是固定的，不依赖于具体平台</li><li><strong>解释执行</strong>：Java字节码可以在任何实现了JVM的平台上解释执行</li><li><strong>高性能</strong>：通过即时编译器(JIT)将热点代码编译为本地机器码</li><li><strong>多线程</strong>：内置多线程支持</li><li><strong>动态性</strong>：Java程序可以在运行时加载和链接新的类</li></ol><h3 id="_2-jdk、jre和jvm的区别" tabindex="-1"><a class="header-anchor" href="#_2-jdk、jre和jvm的区别"><span>2. JDK、JRE和JVM的区别？</span></a></h3><p>答：</p><ul><li><strong>JVM</strong>(Java Virtual Machine)：Java虚拟机，是Java平台无关性的核心，负责执行字节码</li><li><strong>JRE</strong>(Java Runtime Environment)：Java运行时环境，包含JVM和运行Java程序所需的核心类库</li><li><strong>JDK</strong>(Java Development Kit)：Java开发工具包，包含JRE和开发工具(如编译器、调试器等)</li></ul><p>三者的关系：JDK &gt; JRE &gt; JVM</p><h3 id="_3-什么是字节码-采用字节码的好处是什么" tabindex="-1"><a class="header-anchor" href="#_3-什么是字节码-采用字节码的好处是什么"><span>3. 什么是字节码？采用字节码的好处是什么？</span></a></h3><p>答：字节码是Java源代码经过编译器编译后生成的中间代码，是一种与平台无关的二进制码。</p><p>采用字节码的好处：</p><ol><li><strong>平台无关性</strong>：字节码可以在任何安装了JVM的平台上运行</li><li><strong>安全性</strong>：字节码在执行前会经过验证，防止恶意代码执行</li><li><strong>性能优化</strong>：JVM可以对字节码进行优化，如即时编译(JIT)</li><li><strong>动态性</strong>：支持动态加载和链接类</li></ol><h3 id="_4-java和c-的区别" tabindex="-1"><a class="header-anchor" href="#_4-java和c-的区别"><span>4. Java和C++的区别？</span></a></h3><p>答：</p><table><thead><tr><th>特性</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>内存管理</td><td>自动垃圾回收</td><td>手动管理内存</td></tr><tr><td>平台相关性</td><td>平台无关</td><td>平台相关</td></tr><tr><td>多重继承</td><td>不支持类的多重继承，但支持接口的多重实现</td><td>支持多重继承</td></tr><tr><td>指针</td><td>不支持指针操作</td><td>支持指针操作</td></tr><tr><td>运算符重载</td><td>不支持</td><td>支持</td></tr><tr><td>预处理器</td><td>不支持宏定义</td><td>支持宏定义</td></tr><tr><td>goto语句</td><td>不支持</td><td>支持</td></tr></tbody></table><h2 id="面向对象编程" tabindex="-1"><a class="header-anchor" href="#面向对象编程"><span>面向对象编程</span></a></h2><h3 id="_5-面向对象的三大特性是什么" tabindex="-1"><a class="header-anchor" href="#_5-面向对象的三大特性是什么"><span>5. 面向对象的三大特性是什么？</span></a></h3><p>答：面向对象的三大特性是：</p><ol><li><strong>封装</strong>(Encapsulation)：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高代码复用性和安全性</li><li><strong>继承</strong>(Inheritance)：子类可以继承父类的属性和方法，提高代码复用性，使类与类之间产生关系</li><li><strong>多态</strong>(Polymorphism)：同一个对象在程序不同时刻体现的不同状态，提高程序的扩展性和维护性</li></ol><h3 id="_6-什么是重载-overloading-和重写-overriding" tabindex="-1"><a class="header-anchor" href="#_6-什么是重载-overloading-和重写-overriding"><span>6. 什么是重载(Overloading)和重写(Overriding)？</span></a></h3><p>答： <strong>重载</strong>(Overloading)：</p><ul><li>发生在同一类中</li><li>方法名相同，参数列表不同(参数类型、个数、顺序)</li><li>返回值类型可以不同</li><li>访问修饰符可以不同</li><li>在编译时根据参数列表决定调用哪个方法</li></ul><p><strong>重写</strong>(Overriding)：</p><ul><li>发生在父子类中</li><li>方法名、参数列表、返回值类型都相同</li><li>访问修饰符不能更低(如父类为protected，子类不能为private)</li><li>抛出的异常不能更大</li><li>在运行时根据对象的实际类型决定调用哪个方法</li></ul><h3 id="_7-接口和抽象类的区别" tabindex="-1"><a class="header-anchor" href="#_7-接口和抽象类的区别"><span>7. 接口和抽象类的区别？</span></a></h3><p>答：</p><table><thead><tr><th>特性</th><th>接口(Interface)</th><th>抽象类(Abstract Class)</th></tr></thead><tbody><tr><td>关键字</td><td>implements</td><td>extends</td></tr><tr><td>构造方法</td><td>不能有</td><td>可以有</td></tr><tr><td>成员变量</td><td>只能是常量(public static final)</td><td>可以有普通成员变量</td></tr><tr><td>方法</td><td>JDK8前只能是抽象方法，JDK8后可以有默认方法和静态方法</td><td>可以有抽象方法和普通方法</td></tr><tr><td>实现数量</td><td>可以实现多个接口</td><td>只能继承一个抽象类</td></tr><tr><td>访问修饰符</td><td>默认是public</td><td>可以有各种访问修饰符</td></tr></tbody></table><h3 id="_8-equals-和-的区别" tabindex="-1"><a class="header-anchor" href="#_8-equals-和-的区别"><span>8. equals()和==的区别？</span></a></h3><p>答：</p><ul><li><strong>==</strong>： <ul><li>基本数据类型：比较值是否相等</li><li>引用数据类型：比较两个对象的地址是否相同(即是否指向同一个对象)</li></ul></li><li><strong>equals()</strong>： <ul><li>不能比较基本数据类型</li><li>Object类中的equals()方法默认使用==比较，但很多类重写了该方法，如String、Integer等，用于比较对象的内容是否相等</li></ul></li></ul><h3 id="_9-hashcode-和equals-的关系" tabindex="-1"><a class="header-anchor" href="#_9-hashcode-和equals-的关系"><span>9. hashCode()和equals()的关系？</span></a></h3><p>答：</p><ol><li><p><strong>约定</strong>：</p><ul><li>如果两个对象通过equals()比较相等，则它们的hashCode()必须相等</li><li>如果两个对象的hashCode()相等，它们通过equals()比较不一定相等</li><li>如果两个对象的hashCode()不相等，它们通过equals()比较一定不相等</li></ul></li><li><p><strong>重写规则</strong>：</p><ul><li>重写equals()方法时，通常也需要重写hashCode()方法</li><li>保证相等的对象具有相同的哈希码</li></ul></li></ol><h2 id="java集合框架" tabindex="-1"><a class="header-anchor" href="#java集合框架"><span>Java集合框架</span></a></h2><h3 id="_10-java集合框架的整体结构" tabindex="-1"><a class="header-anchor" href="#_10-java集合框架的整体结构"><span>10. Java集合框架的整体结构？</span></a></h3><p>答：Java集合框架主要由两大接口派生而出：Collection和Map</p><p>Collection接口：</p><ul><li><strong>List</strong>：有序、可重复 <ul><li>ArrayList：基于数组实现，查询快，增删慢</li><li>LinkedList：基于链表实现，增删快，查询慢</li><li>Vector：线程安全的ArrayList</li></ul></li><li><strong>Set</strong>：无序、不可重复 <ul><li>HashSet：基于HashMap实现</li><li>TreeSet：基于TreeMap实现，可以排序</li><li>LinkedHashSet：保持插入顺序</li></ul></li><li><strong>Queue</strong>：队列 <ul><li>LinkedList：可以作为队列使用</li><li>PriorityQueue：优先级队列</li></ul></li></ul><p>Map接口：</p><ul><li>HashMap：基于哈希表实现，线程不安全</li><li>TreeMap：基于红黑树实现，可以排序</li><li>LinkedHashMap：保持插入顺序</li><li>Hashtable：线程安全的HashMap</li><li>ConcurrentHashMap：线程安全的HashMap，性能优于Hashtable</li></ul><h3 id="_11-arraylist和linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#_11-arraylist和linkedlist的区别"><span>11. ArrayList和LinkedList的区别？</span></a></h3><p>答：</p><table><thead><tr><th>特性</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>底层实现</td><td>动态数组</td><td>双向链表</td></tr><tr><td>查询效率</td><td>O(1)</td><td>O(n)</td></tr><tr><td>增删效率</td><td>O(n)</td><td>O(1)</td></tr><tr><td>内存占用</td><td>较少</td><td>较多(存储前后节点引用)</td></tr><tr><td>适用场景</td><td>频繁查询、较少增删</td><td>频繁增删、较少查询</td></tr></tbody></table><h3 id="_12-hashmap的实现原理" tabindex="-1"><a class="header-anchor" href="#_12-hashmap的实现原理"><span>12. HashMap的实现原理？</span></a></h3><p>答：HashMap是基于哈希表的Map接口实现，允许null键和null值，不保证映射的顺序。</p><p>JDK1.8之前的实现：</p><ul><li>数组+链表的结构</li><li>通过key的hashCode经过扰动函数处理得到哈希值</li><li>通过(n-1)&amp;hash判断当前元素存放的位置(数组下标)</li><li>如果当前位置存在元素，就判断该元素与要存入元素的hash值和key是否相同，相同则覆盖，不同就拉链法解决冲突</li></ul><p>JDK1.8的优化：</p><ul><li>当链表长度大于阈值(默认为8)时，将链表转换为红黑树</li><li>当红黑树节点少于阈值(默认为6)时，又会转回链表</li><li>这样做的好处是优化了极端情况下的查询效率，从O(n)变为O(logn)</li></ul><h3 id="_13-concurrenthashmap的实现原理" tabindex="-1"><a class="header-anchor" href="#_13-concurrenthashmap的实现原理"><span>13. ConcurrentHashMap的实现原理？</span></a></h3><p>答：ConcurrentHashMap是线程安全的HashMap，在JDK1.7和JDK1.8有不同的实现方式：</p><p>JDK1.7：</p><ul><li>使用分段锁(Segment)机制</li><li>将数据分成一段一段的存储，给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问</li><li>Segment继承ReentrantLock，用来充当锁的角色</li></ul><p>JDK1.8：</p><ul><li>取消了Segment分段锁，采用CAS+Synchronized来保证并发安全</li><li>数据结构跟HashMap1.8的结构一样，数组+链表+红黑树</li><li>synchronized只锁定当前链表或红黑树的首节点，这样只要hash不冲突，就不会产生并发问题</li></ul><h2 id="异常处理" tabindex="-1"><a class="header-anchor" href="#异常处理"><span>异常处理</span></a></h2><h3 id="_14-java异常体系结构" tabindex="-1"><a class="header-anchor" href="#_14-java异常体系结构"><span>14. Java异常体系结构？</span></a></h3><p>答：Java异常体系以Throwable为根类：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">Throwable</span>
<span class="line">├── Error(错误)</span>
<span class="line">│   ├── VirtualMachineError</span>
<span class="line">│   ├── IOError</span>
<span class="line">│   └── ...</span>
<span class="line">└── Exception(异常)</span>
<span class="line">    ├── RuntimeException(运行时异常)</span>
<span class="line">    │   ├── NullPointerException</span>
<span class="line">    │   ├── IndexOutOfBoundsException</span>
<span class="line">    │   ├── IllegalArgumentException</span>
<span class="line">    │   └── ...</span>
<span class="line">    └── CheckedException(检查异常)</span>
<span class="line">        ├── IOException</span>
<span class="line">        ├── SQLException</span>
<span class="line">        └── ...</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_15-error和exception的区别" tabindex="-1"><a class="header-anchor" href="#_15-error和exception的区别"><span>15. Error和Exception的区别？</span></a></h3><p>答：</p><ul><li><strong>Error</strong>： <ul><li>表示JVM无法处理的严重问题</li><li>程序不应该捕获或处理这类异常</li><li>如OutOfMemoryError、StackOverflowError等</li></ul></li><li><strong>Exception</strong>： <ul><li>表示程序可以处理的异常</li><li>可以被捕获并处理</li><li>分为检查异常(CheckedException)和运行时异常(RuntimeException)</li></ul></li></ul><h3 id="_16-throw和throws的区别" tabindex="-1"><a class="header-anchor" href="#_16-throw和throws的区别"><span>16. throw和throws的区别？</span></a></h3><p>答：</p><ul><li><strong>throw</strong>： <ul><li>在方法体内使用，用于抛出一个具体的异常对象</li><li>后面跟的是异常类的实例</li><li>例如：<code>throw new IllegalArgumentException(&quot;参数不合法&quot;);</code></li></ul></li><li><strong>throws</strong>： <ul><li>在方法声明时使用，用于声明该方法可能抛出的异常</li><li>后面跟的是异常类名</li><li>例如：<code>public void readFile() throws IOException {}</code></li></ul></li></ul><h2 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型"><span>泛型</span></a></h2><h3 id="_17-什么是泛型-有什么优点" tabindex="-1"><a class="header-anchor" href="#_17-什么是泛型-有什么优点"><span>17. 什么是泛型？有什么优点？</span></a></h3><p>答：泛型是JDK1.5引入的特性，允许在定义类、接口和方法时使用类型形参。</p><p>优点：</p><ol><li><strong>类型安全</strong>：在编译时检查类型安全，避免运行时ClassCastException</li><li><strong>消除强制类型转换</strong>：不需要显式的类型转换</li><li><strong>提高代码复用性</strong>：同一个类或方法可以处理多种类型的数据</li></ol><h3 id="_18-泛型中的pecs原则是什么" tabindex="-1"><a class="header-anchor" href="#_18-泛型中的pecs原则是什么"><span>18. 泛型中的PECS原则是什么？</span></a></h3><p>答：PECS是Producer Extends Consumer Super的缩写：</p><ul><li><strong>PE</strong>：如果需要一个只读的泛型集合(生产者)，应该使用&lt;? extends T&gt;</li><li><strong>CS</strong>：如果需要一个只写的泛型集合(消费者)，应该使用&lt;? super T&gt;</li></ul><p>这样设计的原则是为了保证类型安全。</p><h2 id="io-nio" tabindex="-1"><a class="header-anchor" href="#io-nio"><span>IO/NIO</span></a></h2><h3 id="_19-bio、nio、aio的区别" tabindex="-1"><a class="header-anchor" href="#_19-bio、nio、aio的区别"><span>19. BIO、NIO、AIO的区别？</span></a></h3><p>答：</p><ul><li><p><strong>BIO</strong>(Blocking IO)：</p><ul><li>同步阻塞IO</li><li>一个连接对应一个线程</li><li>适用于连接数目比较小且固定的架构</li></ul></li><li><p><strong>NIO</strong>(Non-blocking IO)：</p><ul><li>同步非阻塞IO</li><li>一个线程处理多个连接</li><li>通过Selector轮询注册在其上的Channel，实现一个线程处理多个连接</li></ul></li><li><p><strong>AIO</strong>(Asynchronous IO)：</p><ul><li>异步非阻塞IO</li><li>引入了异步通道的概念，采用了Proactor模式</li><li>有效的请求才启动线程，特点是先由操作系统完成后才通知服务端启动线程去处理</li></ul></li></ul><h3 id="_20-nio的核心组件有哪些" tabindex="-1"><a class="header-anchor" href="#_20-nio的核心组件有哪些"><span>20. NIO的核心组件有哪些？</span></a></h3><p>答：NIO的核心组件包括：</p><ol><li><strong>Channel</strong>(通道)：表示到实体(如硬件设备、文件、网络套接字)的开放连接</li><li><strong>Buffer</strong>(缓冲区)：本质上是一个容器对象，提供对数据的结构化访问以及在缓冲区和通道进行交互</li><li><strong>Selector</strong>(选择器)：用于监听多个Channel的事件，实现单线程管理多个Channel</li></ol><h2 id="反射" tabindex="-1"><a class="header-anchor" href="#反射"><span>反射</span></a></h2><h3 id="_21-什么是反射-有什么作用" tabindex="-1"><a class="header-anchor" href="#_21-什么是反射-有什么作用"><span>21. 什么是反射？有什么作用？</span></a></h3><p>答：反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。</p><p>作用：</p><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li><li>生成动态代理</li></ol><h3 id="_22-反射的优缺点" tabindex="-1"><a class="header-anchor" href="#_22-反射的优缺点"><span>22. 反射的优缺点？</span></a></h3><p>答： <strong>优点</strong>：</p><ol><li>运行期类型的判断，动态加载类</li><li>提高了程序的灵活性和扩展性</li></ol><p><strong>缺点</strong>：</p><ol><li>性能开销大：反射操作涉及动态解析，JVM无法对这些代码进行优化</li><li>安全限制：反射可能破坏封装性</li><li>模糊程序内部逻辑：代码可读性下降，维护困难</li></ol><h2 id="注解" tabindex="-1"><a class="header-anchor" href="#注解"><span>注解</span></a></h2><h3 id="_23-什么是注解-有哪些内置注解" tabindex="-1"><a class="header-anchor" href="#_23-什么是注解-有哪些内置注解"><span>23. 什么是注解？有哪些内置注解？</span></a></h3><p>答：注解是JDK1.5引入的特性，是一种元数据，提供有关程序但不属于程序本身的数据。</p><p>常用的内置注解：</p><ol><li><strong>@Override</strong>：检查该方法是否是重写方法</li><li><strong>@Deprecated</strong>：标记过时的元素</li><li><strong>@SuppressWarnings</strong>：抑制编译器警告</li><li><strong>@FunctionalInterface</strong>：标识函数式接口(JDK8)</li></ol><h3 id="_24-元注解有哪些" tabindex="-1"><a class="header-anchor" href="#_24-元注解有哪些"><span>24. 元注解有哪些？</span></a></h3><p>答：元注解是用于注解其他注解的注解：</p><ol><li><strong>@Retention</strong>：指定注解的保留策略(SOURCE/CLASS/RUNTIME)</li><li><strong>@Target</strong>：指定注解可以应用的目标类型</li><li><strong>@Documented</strong>：标记注解应该被javadoc工具记录</li><li><strong>@Inherited</strong>：标记注解可以被继承</li><li><strong>@Repeatable</strong>：标记注解可以重复使用(JDK8)</li></ol><h2 id="java-8新特性" tabindex="-1"><a class="header-anchor" href="#java-8新特性"><span>Java 8新特性</span></a></h2><h3 id="_25-lambda表达式是什么-有什么优势" tabindex="-1"><a class="header-anchor" href="#_25-lambda表达式是什么-有什么优势"><span>25. Lambda表达式是什么？有什么优势？</span></a></h3><p>答：Lambda表达式是JDK8引入的重要特性，是一种匿名函数，可以不需要名称，但有参数列表、函数主体、返回类型和可能抛出的异常列表。</p><p>优势：</p><ol><li><strong>简洁性</strong>：代码更加简洁</li><li><strong>函数式编程</strong>：支持函数式编程风格</li><li><strong>并行处理</strong>：结合Stream API可以轻松实现并行处理</li></ol><h3 id="_26-stream-api有什么作用" tabindex="-1"><a class="header-anchor" href="#_26-stream-api有什么作用"><span>26. Stream API有什么作用？</span></a></h3><p>答：Stream API是JDK8引入的用来处理集合的API，提供了一种高效且易于使用的处理数据的方式。</p><p>特点：</p><ol><li><strong>无存储</strong>：Stream不是数据结构，不保存数据</li><li><strong>函数式</strong>：对Stream的任何修改都不会修改背后的数据源</li><li><strong>惰性求值</strong>：许多Stream操作都是惰性的，只有在结果真正需要时才会执行</li><li><strong>可消费性</strong>：Stream只能被消费一次，一旦遍历完就失效</li></ol><h2 id="jvm相关" tabindex="-1"><a class="header-anchor" href="#jvm相关"><span>JVM相关</span></a></h2><h3 id="_27-java程序的执行过程" tabindex="-1"><a class="header-anchor" href="#_27-java程序的执行过程"><span>27. Java程序的执行过程？</span></a></h3><p>答：Java程序的执行过程如下：</p><ol><li>编写Java源代码(.java文件)</li><li>使用javac命令编译源代码生成字节码文件(.class文件)</li><li>JVM中的类加载器加载.class文件</li><li>JVM中的执行引擎执行字节码，将字节码翻译成机器码在操作系统上运行</li></ol><h3 id="_28-什么是类加载机制" tabindex="-1"><a class="header-anchor" href="#_28-什么是类加载机制"><span>28. 什么是类加载机制？</span></a></h3><p>答：类加载机制是指虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程。</p><p>类加载过程包括：</p><ol><li><strong>加载</strong>：通过类的全限定名获取定义此类的二进制字节流，并将静态存储结构转化为方法区的运行时数据结构，在内存中生成代表这个类的Class对象</li><li><strong>验证</strong>：确保Class文件的字节流中包含的信息符合当前虚拟机的要求</li><li><strong>准备</strong>：为类变量分配内存并设置类变量初始值</li><li><strong>解析</strong>：将常量池内的符号引用替换为直接引用</li><li><strong>初始化</strong>：执行类构造器&lt;clinit&gt;()方法</li></ol><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h2><h3 id="_29-常见的设计模式有哪些" tabindex="-1"><a class="header-anchor" href="#_29-常见的设计模式有哪些"><span>29. 常见的设计模式有哪些？</span></a></h3><p>答：常见的设计模式包括： <strong>创建型模式</strong>：</p><ul><li>单例模式(Singleton)</li><li>工厂方法模式(Factory Method)</li><li>抽象工厂模式(Abstract Factory)</li><li>建造者模式(Builder)</li><li>原型模式(Prototype)</li></ul><p><strong>结构型模式</strong>：</p><ul><li>适配器模式(Adapter)</li><li>装饰器模式(Decorator)</li><li>代理模式(Proxy)</li><li>外观模式(Facade)</li><li>桥接模式(Bridge)</li><li>组合模式(Composite)</li><li>享元模式(Flyweight)</li></ul><p><strong>行为型模式</strong>：</p><ul><li>策略模式(Strategy)</li><li>模板方法模式(Template Method)</li><li>观察者模式(Observer)</li><li>迭代器模式(Iterator)</li><li>责任链模式(Chain of Responsibility)</li><li>命令模式(Command)</li><li>备忘录模式(Memento)</li><li>状态模式(State)</li><li>访问者模式(Visitor)</li><li>中介者模式(Mediator)</li><li>解释器模式(Interpreter)</li></ul><h3 id="_30-单例模式有几种实现方式" tabindex="-1"><a class="header-anchor" href="#_30-单例模式有几种实现方式"><span>30. 单例模式有几种实现方式？</span></a></h3><p>答：单例模式有多种实现方式：</p><ol><li><strong>饿汉式</strong>：</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">public class Singleton {</span>
<span class="line">    private static final Singleton INSTANCE = new Singleton();</span>
<span class="line">    </span>
<span class="line">    private Singleton() {}</span>
<span class="line">    </span>
<span class="line">    public static Singleton getInstance() {</span>
<span class="line">        return INSTANCE;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>懒汉式(线程不安全)</strong>：</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">public class Singleton {</span>
<span class="line">    private static Singleton instance;</span>
<span class="line">    </span>
<span class="line">    private Singleton() {}</span>
<span class="line">    </span>
<span class="line">    public static Singleton getInstance() {</span>
<span class="line">        if (instance == null) {</span>
<span class="line">            instance = new Singleton();</span>
<span class="line">        }</span>
<span class="line">        return instance;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>懒汉式(线程安全)</strong>：</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">public class Singleton {</span>
<span class="line">    private static Singleton instance;</span>
<span class="line">    </span>
<span class="line">    private Singleton() {}</span>
<span class="line">    </span>
<span class="line">    public static synchronized Singleton getInstance() {</span>
<span class="line">        if (instance == null) {</span>
<span class="line">            instance = new Singleton();</span>
<span class="line">        }</span>
<span class="line">        return instance;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><strong>双重检查锁定</strong>：</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">public class Singleton {</span>
<span class="line">    private static volatile Singleton instance;</span>
<span class="line">    </span>
<span class="line">    private Singleton() {}</span>
<span class="line">    </span>
<span class="line">    public static Singleton getInstance() {</span>
<span class="line">        if (instance == null) {</span>
<span class="line">            synchronized (Singleton.class) {</span>
<span class="line">                if (instance == null) {</span>
<span class="line">                    instance = new Singleton();</span>
<span class="line">                }</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        return instance;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li><strong>静态内部类</strong>：</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">public class Singleton {</span>
<span class="line">    private Singleton() {}</span>
<span class="line">    </span>
<span class="line">    private static class SingletonHolder {</span>
<span class="line">        private static final Singleton INSTANCE = new Singleton();</span>
<span class="line">    }</span>
<span class="line">    </span>
<span class="line">    public static Singleton getInstance() {</span>
<span class="line">        return SingletonHolder.INSTANCE;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="6"><li><strong>枚举</strong>：</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">public enum Singleton {</span>
<span class="line">    INSTANCE;</span>
<span class="line">    </span>
<span class="line">    public void doSomething() {</span>
<span class="line">        // Business method</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>以上是Java基础相关的常见面试题及参考答案。这些知识点涵盖了Java语言的核心概念，是Java程序员必须掌握的基础知识。在准备面试时，不仅要记住这些知识点，还要理解其背后的原理和应用场景。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated:: </span><time class="meta-item-info" datetime="2025-12-11T06:51:20.000Z" data-allow-mismatch>12/11/25, 6:51 AM</time></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1127699551@qq.com">mingwzh</span><!----><!--]--><!--]--></span></div></div></footer><nav class="vp-page-nav" aria-label="page navigation"><!----><a class="route-link auto-link next" href="/java/jmm-notes.html" aria-label="Java内存模型(JMM)学习笔记"><!--[--><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span class="external-link">Java内存模型(JMM)学习笔记</span></div><!--]--></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-BvwJZ6kh.js" defer></script>
  </body>
</html>
